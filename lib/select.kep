/**
 * @fileOverview Sub stream selection.
 */
package (
    takeWhile,
    take,
    skipWhile,
    skip)
with
    import 'nu/stream' {end, first, isEmpty, stream, rest}
in {

/* Gen
 ******************************************************************************/
/**
 * Create a stream of elements yielded from 's' while a predicate is
 * satisfied. Stops yielding elements once the predicate is not satisfied.
 * 
 * @param {function(value): boolean} pred Predicate function that determines when
 *     to take elements.
 * @param s Stream to take elements from.
 * 
 * @returns Lazy stream of elements taken from 's'.
 */
takeWhile = (
    let takeWhile = \i, pred, s -> {
        if (isEmpty(s))
            return s;
        var x = first(s);
        return (pred(x, i) ?
            stream(x, (takeWhile, i + 1, pred, rest(s))) :
            end);
    } in takeWhile,
    0);

/**
 * Create a stream of at most 'count' elements from 's'.
 * 
 * May yield fewer than 'count' elements if 's' ends.
 * 
 * @param {Number} count Number of elements to take. Must be greater than or 
 *     equal to zero. Defaults to 'Infinity'.
 *  @param s Stream to take elements from.
 * 
 * @returns Lazy stream of at most 'count' elements from 's'.
 */
take = \count, s ->
    (isNaN(count) || count < 0 ?
        s : 
        takeWhile(\_, i -> (i < count), s));

/**
 * Create a stream that skips leading elements from 's' while a predicate is
 * satisfied.
 * 
 * May result in an empty stream if 's' ends before the predicate is satisfied.
 * 
 * @param {function(value, index): boolean} pred Predicate that determines 
 *     elements to skip.
 * * @param s Stream to yield elements from.
 * 
 * @returns Stream of elements from 's' after predicate was not satisfied.
 */
skipWhile = \pred, s -> {
    for (var head = s, i = 0; !isEmpty(head); head = rest(head)) {
        if (!pred(first(head), i))
            return head;
        i = i + 1;
    }
    return end;
};

/**
 * Create a stream that skips 'count' elements from 's'.
 * 
 * @param s Stream to yield elements from.
 * @param {Number} count Number of elements to skip.
 * 
 * @returns Stream of elements from 's' after 'count' elements.
 */
skip = \count, s ->
    (isNaN(count) || count <= 0 ?
        s :
        skipWhile(\_, i -> (i < count), s));

}