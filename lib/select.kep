/**
 * @fileOverview Sub stream selection.
 */
package (
    takeWhile,
    take,
    skipWhile,
    skip)
with
    import 'nu/stream' {
        end,
        first,
        isEmpty,
        map,
        stream,
        rest,
        indexed}
in {

var value = \[i, x] -> x;
var index = \[i, x] -> i;

/* Selections
 ******************************************************************************/
/**
 * Create a stream of elements yielded from 's' while a predicate is
 * satisfied. Stops yielding elements once the predicate is not satisfied.
 * 
 * @param {function(value): boolean} pred Predicate function that determines when
 *     to take elements.
 * @param s Stream to take elements from.
 * 
 * @returns Lazy stream of elements taken from 's'.
 */
takeWhile = \pred, s ->
    (isEmpty(s) ? s :
        let x = first(s) in
            (pred(x) ?
                stream(x, (takeWhile, pred, rest(s))) :
                end));

/**
 * Create a stream of at most 'count' elements from 's'.
 * 
 * May yield fewer than 'count' elements if 's' ends.
 * 
 * @param {Number} count Number of elements to take. Must be greater than or 
 *     equal to zero. Defaults to 'Infinity'.
 *  @param s Stream to take elements from.
 * 
 * @returns Lazy stream of at most 'count' elements from 's'.
 */
take = \count, s ->
    (isNaN(count) || count < 0 ?
        s : 
        map(
            value,
            takeWhile(
                index \> (>, count), 
                indexed <| s)));

/**
 * Create a stream that skips leading elements from 's' while a predicate is
 * satisfied.
 * 
 * May result in an empty stream if 's' ends before the predicate is satisfied.
 * 
 * @param {function(value): boolean} pred Predicate that determines 
 *     elements to skip.
 * * @param s Stream to yield elements from.
 * 
 * @returns Stream of elements from 's' after predicate was not satisfied.
 */
skipWhile = \pred, s -> {
    for (var head = s; !isEmpty(head); head = rest(head))
        if (!pred(first(head)))
            return head;
    return end;
};

/**
 * Create a stream that skips 'count' elements from 's'.
 * 
 * @param s Stream to yield elements from.
 * @param {Number} count Number of elements to skip.
 * 
 * @returns Stream of elements from 's' after 'count' elements.
 */
skip = \count, s ->
    (isNaN(count) || count <= 0 ?
        s :
        map(
            value,
            skipWhile(
                index \> (>, count),
                indexed <| s)));

}