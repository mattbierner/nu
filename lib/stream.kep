/**
 * @fileOverview Core stream functionality.
 */
define(function() {
"use strict";

var arrayReduce = Array.prototype.reduce;

/* Helper functions
 ******************************************************************************/
var curry = (f /*, ...*/) ->
    (arguments.length === 1 ?
        f :
        f.bind.apply(f, arguments));

var identity = x -> x;

var constant = curry(curry, identity);

var memo = f -> {
    var value;
    return (/*...*/) -> 
         (value === undefined ?
            (value = f.apply(undefined, arguments)) :
            value);
};

/* Constants
 ******************************************************************************/
/**
 * The empty stream.
 */
var end = null;

/* Stream Construction
 ******************************************************************************/
/**
 * Create a new stream.
 *
 * @param val First element of the stream.
 * @param f Function that returns the rest of the stream given the first element.
 * 
 * @return A new stream.
 */
var stream = (val, f) -> ({
    'first': val,
    'rest': f
});

/**
 * Create a new stream that memoizes rest results.
 */
var memoStream = (val, f) -> ({
    'first': val,
    'rest': memo(f)
});

/**
 * Create a new stream from a value and existing stream.
 * 
 * @param val First element of the stream.
 * @param s Rest of the stream.
 * 
 * @return A new stream.
 */
var cons = (val, s) -> 
    stream(val, constant(s));

/**
 * Joins two streams into a new stream.
 * 
 * @param s1 Stream
 * @param f Function returning second stream.
 * 
 * @return Stream of two joined streams.
 */
var appendz = (s1, f) ->
    (isEmpty(s1) ?
        f() :
        stream(first(s1), curry(appendz, rest(s1), f)));

/**
 * Joins multiple streams into a new stream.
 * 
 * @return Stream of joined streams.
 */
var append = (function(){
    var reducer = (s1, s2) ->
        appendz(s1, constant(s2));
    
    return (/*...*/) ->
        (arguments.length === 0 ?
            end :
            arrayReduce.call(arguments, reducer));
}());

/**
 * Joins a stream of streams into a new stream
 */
var concat = s ->
    (isEmpty(s) ?
        s :
        appendz(first(s), curry(concat, rest(s))));

/**
 * Create a new stream from an enumerable object.
 * 
 * @param enumerable Enumerable object.
 * 
 * @return Stream of enumerable values from enumerable object.
 */
var from = (function(){
    var fromImpl = (enumerable, i, len) ->
        (i >= len ?
            end : 
            memoStream(enumerable[i], curry(fromImpl, enumerable, i + 1, len)));
    
    return function STREAM_FROM(enumerable) {
        return (enumerable === undefined ?
            end :
            fromImpl(enumerable, 0, enumerable.length));
    };
}());

/* Primitive Operators
 ******************************************************************************/
/**
 * Get the first element of a given stream.
 * 
 * @param s Stream.
 * 
 * @return First element of 's'.
 */
var first = s -> s.first;

/**
 * Get the rest of a given stream, excluding the first element.
 * 
 * @param s Stream.
 * 
 * @return Stream for rest of 's'.
 */
var rest = s -> s.rest(first(s));

/**
 * Is a given stream empty.
 * 
 * @param s Stream.
 *
 *@return Is 's' empty.
 */
var isEmpty = s -> (s === end);

/**
 * Is a given object a stream?
 * 
 * @param s Object to test.
 * 
 * @return Is 's' a valid stream.
 */
var isStream = s ->
    (s && s.hasOwnProperty('first') && s.hasOwnProperty('rest'));
/* 
 ******************************************************************************/
/**
 * Iterate over a stream.
 *
 * @param s Stream being iterated over.
 * @param {function(value, index): *} f Function called for each element of 's'.
 */
var forEach = function(s, f) {
    var i = 0;
    while (!isEmpty(s)) {
       f(first(s), i);
       ++i;
       s = rest(s);
    }
};

/**
 * Left fold on a stream.
 * 
 * @param {function(previous, current, index)} f Function that reduces 
 *     's'.
 * @param z Initial value used for fold.
 * @param s Stream being reduced.
 * 
 * @return Result of reduction.
 */
var foldl = function(f, z, s) {
    forEach(s, (x, i) -> 
        (z = f(z, x, i)));
    return z;
};

/**
 * Right fold on a stream.
 *
 * @param {function(previous, current, index)} f Function that reduces 's'.
 * @param z Initial value used for fold.
 * @param s Stream being reduced.
 * 
 * @return Result of reduction.
 */
var foldr = curry(function STREAM_FOLDR(i, f, z, s) {
    return (isEmpty(s) ?
        z :
        f(STREAM_FOLDR(i + 1, f, z, rest(s)), first(s), i));
}, 0);

/**
 * Reduces a stream right to left.
 *
 * @param s Stream being reduced.
 *
 * @return Array created from stream..
 */
var toArray = curry(foldl, (p, c) -> p.concat(c), []);

/* 
 ******************************************************************************/
/**
 * Create a new stream of mapped values from an existing stream.
 * 
 * @param {function(value)} f Function that transforms source values and
 *     returns the transformed value.
 * @param source Stream to map.
 * 
 * @return Stream of mapped values.
 */
var map = curry(function STREAM_MAP(i, f, s) {
    return (isEmpty(s) ?
        s :
        memoStream(f(first(s), i), curry(STREAM_MAP, i + 1, f, rest(s))));
}, 0);

/**
 * Create a new stream of filtered values from an existing stream.
 * 
 * @param {function(value, index): boolean} predicate Predicate function used to filter
 *     stream. Takes the value to test as well as its index in
 *     the unfiltered source.
 * * @param s Stream being filtered.
 * 
 * @return New stream from filtered 's'.
 */
var filter = curry(function STREAM_FILTER(i, pred, s) {
    while (!isEmpty(s)) {
        var x = first(s);
        if (pred(x, i)) {
            return memoStream(x, curry(STREAM_FILTER, i + 1, pred, rest(s)));
        }
        ++i;
        s = rest(s);
    }
    return s;
}, 0);

/* 
 ******************************************************************************/
/**
 * Apply 'f' to stream 's' and join results into a new stream.
 */
var bind = (f, s) ->
     concat(map(f, s));

/* Export
 ******************************************************************************/
return {
    'end': end,

    'stream': stream,
    'memoStream': memoStream,
    
    'cons': cons,
    'append': append,
    'appendz': appendz,
    'concat': concat,
    'from': from,

    'first': first,
    'rest': rest,
    'isEmpty': isEmpty,
    'isStream': isStream,
    
    'forEach': forEach,
    'foldl': foldl,
    'foldr': foldr,
    'toArray': toArray,
    
    'map': map,
    'filter': filter,
    
    'bind': bind
};


});