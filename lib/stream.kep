/**
 * @fileOverview Core stream functionality.
 */
package (
    end,
    NIL,
    
    stream,
    memoStream,
    
    cons,
    append,
    appendz,
    concat,
    from,

    first,
    rest,
    isEmpty,
    isStream,
    
    forEach,
    
    reverse,
    foldl,
    foldr,
    reduce,
    reduceRight,
    toArray,
    
    zip,
    indexed,
    
    map,
    filter,
    
    bind)
{

var arrayReduce = Function.prototype.call.bind(Array.prototype.reduce);

var constant = \x -> \() -> x;

var flip = \f -> \x, y -> f(y, x);

var memo = \f -> {
    var value;
    return \args(...) -> {
        if (value === undefined)
            value = f.apply(this, args);
        return value;
    };
};

/* Constants
 ******************************************************************************/
/**
 * The empty stream.
 */
end = null;
NIL = end;

/* Stream
 ******************************************************************************/
/**
 * Create a new stream.
 *
 * @param val First element of the stream.
 * @param f Function that returns the rest of the stream given the first element.
 * 
 * @return A new stream.
 */
stream = \val, f -> ({
    'first': val,
    'rest': f
});

/**
 * Create a new stream that memoizes rest results.
 */
memoStream = \val, f ->
    stream(val, memo(f));

/* Primitive Operators
 ******************************************************************************/
/**
 * Get the first element of a given stream.
 * 
 * @param s Stream.
 * 
 * @return First element of 's'.
 */
first = \s -> s.first;

/**
 * Get the rest of a given stream, excluding the first element.
 * 
 * @param s Stream.
 * 
 * @return Stream for rest of 's'.
 */
rest = \s -> s.rest(first(s));

/**
 * Is a given stream empty.
 * 
 * @param s Stream.
 *
 *@return Is 's' empty.
 */
isEmpty = \s -> (s === end);

/**
 * Is a given object a stream?
 * 
 * Returns true for empty streams as well.
 * 
 * @param s Object to test.
 * 
 * @return Is 's' a valid stream.
 */
isStream = \s ->
    ((s && s.hasOwnProperty('first') && s.hasOwnProperty('rest')) || s === end);

/* Stream Construction
 ******************************************************************************/
/**
 * Create a new stream from a value and existing stream.
 * 
 * @param val First element of the stream.
 * @param s Rest of the stream.
 * 
 * @return A new stream.
 */
cons = \val, s -> 
    stream(val, constant(s));

/**
 * Joins two streams into a new stream.
 * 
 * @param s1 Stream.
 * @param f Function returning second stream.
 * 
 * @return Stream of two joined streams.
 */
appendz = \s1, f ->
    (isEmpty(s1) ?
        f() :
        memoStream(first(s1), (appendz, rest(s1), f)));

/**
 * Joins multiple streams into a new stream.
 * 
 * @return Stream of joined streams.
 */
append = let
    reducer = \s1, s2 -> appendz(s1, constant(s2))
in
    \streams(...) -> arrayReduce(streams, reducer, end);

/**
 * Joins a stream of streams into a new stream
 */
concat = \s ->
    (isEmpty(s) ?
        s :
        appendz(first(s), (concat, rest(s))));

/**
 * Create a new stream from an array like object.
 * 
 * @param arr Array like object object.
 * 
 * @return Stream of enumerable values from enumerable object.
 */
from = let
    fromImpl = \arr, i, len ->
        (i >= len ?
            end : 
            memoStream(arr[i], (fromImpl, arr, i + 1, len)))
in
    \arr{length} -> fromImpl(arr, 0, length);

/* 
 ******************************************************************************/

/**
 * Combine two streams into a stream of pairs.
 * 
 * Takes as many elements as the shorter of the two contains.
 * 
 * @param l1 Stream
 * @param l2 Stream
 */
zip = \l1, l2 ->
    (isEmpty(l1) || isEmpty(l2) ? end :
        memoStream(
            [first(l1), first(l2)],
            (zip, rest(l1), rest(l2))));

/**
 * Create a stream of pairs of index and value.
 */
indexed = let
    count = \n -> stream(n, (+, 1) \> count)
in
    (zip, count(0));

/**
 * Iterate over a stream in order.
 *
 * @param {function(value): *} f Function to call each element of 's'.
 * @param s Stream to iterate over.
 */
forEach = \f, s -> {
    for (var head = s; !isEmpty(head); head = rest(head))
       f(first(head));
};

/**
 * Left fold on a stream.
 * 
 * @param {function(previous, current)} f Function that reduces 
 *     's'.
 * @param z Initial value used for fold.
 * @param s Stream.
 * 
 * @return Result of reduction.
 */
foldl = \f, z, s -> {
    var r = z;
    forEach(\x -> { r = f(r, x); }, s);
    return r;
};

/**
 * Reverse a stream.
 * 
 * Must be finite.
 * 
 * @param s Stream.
 */
reverse = (foldl,
    flip(cons),
    end);

/**
 * Right fold on a stream.
 *
 * @param {function(previous, current)} f Function that reduces 's'.
 * @param z Initial value used for fold.
 * @param s Stream.
 * 
 * @return Result of reduction.
 */
foldr = \f, z, s ->
    foldl(f, z, reverse <| s);

/**
 * Left fold on a non empty stream without an initial value.
 * 
 * @param {function(previous, current)} f Function that reduces 
 *     's'.
 * @param s Stream.
 * 
 * @return Result of reduction.
 */
reduce = \f, s ->
    foldl(f, first(s), rest(s));

/**
 * right fold on a non empty stream without an initial value.
 * 
 * @param {function(previous, current)} f Function that reduces 
 *     's'.
 * @param s Stream.
 * 
 * @return Result of reduction.
 */
reduceRight = \f, s ->
    reduce(f, reverse <| s);

/**
 * Convert a finite stream to an array.
 *
 * @param s Stream.
 *
 * @return Array created from stream..
 */
toArray = let
    builder = \p, c -> {
        p.push(c);
        return p;
    }
in
    \s -> foldl(builder, [], s);

/* 
 ******************************************************************************/
/**
 * Create a new stream of mapped values from an existing stream.
 * 
 * @param {function(value)} f Function that transforms source values and
 *     returns the transformed value.
 * @param source Stream to map.
 * 
 * @return Stream of mapped values.
 */
map = \f, s ->
    (isEmpty(s) ? s :
        memoStream(f(first(s)), (map, f, rest(s))));

/**
 * Create a new stream of filtered values from an existing stream.
 * 
 * @param {function(value): boolean} predicate Predicate function used to filter
 *     stream. 
 * * @param s Stream being filtered.
 * 
 * @return New stream from filtered 's'.
 */
filter = \pred, s -> {
    var head = s;
    for (; !isEmpty(head); head = rest(head)) {
        var x = first(head);
        if (pred(x))
            return memoStream(x, (filter, pred, rest(head)));
    }
    return head;
};

/* 
 ******************************************************************************/
/**
 * Apply 'f' to stream 's' and join results into a new stream.
 */
bind = map \>> concat;

}